
# Tabla de contenidos

1.  [Parte 1: git rebase para mantener un historial lineal](#orgbc5caaa)
    1.  [Rama inicial](#orga3b18b0)
    2.  [Rama new-feature](#org09f2504)
    3.  [git rebase y merge](#orge4a61b8)
        1.  [Rebase](#org9a4a06e)
        2.  [Merge](#orgdaf8d3c)
2.  [Parte 2: git cherry-pick para la integraci√≥n selectiva de commit](#org2a240b1)
    1.  [Diagrama de ramas](#org6d5a535)
    2.  [Cherry-pick](#orgda25e53)
    3.  [Preguntas de discusi√≥n](#org45b8fba)
3.  [Ejercicios Te√≥ricos](#orga208616)
4.  [Ejercicios pr√°cticos](#org36c957d)
5.  [Git, Scrum y Sprints](#org5710cd9)
    1.  [Fase 1: Planificaci√≥n del sprint (sprint planning)](#orgd6f8434)
        1.  [Ejercicio 1: Crear ramas de funcionalidades (feature branches)](#org117e6a9)
    2.  [Fase 2: Desarrollo del sprint (sprint execution)](#org9b00752)
        1.  [Ejercicio 2: Integraci√≥n continua con git rebase](#org0f307e4)
    3.  [Fase 3: Revisi√≥n del sprint (sprint review)](#org9b63802)
        1.  [Ejercicio 3: Integraci√≥n selectiva con git cherry-pick](#org99acda5)
    4.  [Fase 4: Retrospectiva del sprint (sprint retrospective)](#org290fe7d)
        1.  [Ejercicio 4: Revisi√≥n de conflictos y resoluci√≥n](#org345c435)
    5.  [Fase 5: Fase de desarrollo, automatizaci√≥n de integraci√≥n continua (CI) con git rebase](#orgdca9680)
        1.  [Ejercicio 5: Automatizaci√≥n de rebase con hooks de Git](#orgbab3088)
    6.  [Navegando conflictos y versionado en un entorno DevOps](#orgd8eb8ed)
6.  [Preguntas](#orge2e932d)



<a id="orgbc5caaa"></a>

# Parte 1: git rebase para mantener un historial lineal


<a id="orga3b18b0"></a>

## Rama inicial

Despu√©s de crear el repositorio `prueba-git-rebase` y realizar los commits correspondientes, as√≠ se ve el gr√°fico en la rama `main`.

![Gr√°fico de la primera rama del primer repositorio](../resources/img/A6_P1_1.jpg)


<a id="org09f2504"></a>

## Rama new-feature

![Gr√°fico de la nueva rama en el primer repositorio](../resources/img/A6_P1_2.jpg)


<a id="orge4a61b8"></a>

## git rebase y merge


<a id="org9a4a06e"></a>

### Rebase

![Gr√°fico despu√©s de rebase en el primer repositorio](../resources/img/A6_P1_3.jpg)


<a id="orgdaf8d3c"></a>

### Merge

![Gr√°fico despu√©s de merge en el primer repositorio](../resources/img/A6_P1_4.jpg)


<a id="org2a240b1"></a>

# Parte 2: git cherry-pick para la integraci√≥n selectiva de commit

Despu√©s de la inicializaci√≥n del segundo repositorio y creaci√≥n de la rama `add-base-documents`, as√≠ se ve el gr√°fico del repositorio:

[Gr√°fico inicial del segundo repositorio](../resources/img/A6_P2_1.jpg)


<a id="org6d5a535"></a>

## Diagrama de ramas

![Diagrama de ramas](../resources/img/A6_P2_2.jpg)


<a id="orgda25e53"></a>

## Cherry-pick

Realizando un cherry pick en el commit `db5e7b7` a la rama principal, se tiene el siguiente gr√°fico:

![Gr√°fico del segundo repositorio tras cherry-pick](../resources/img/A6_P2_3.jpg)

Este nuevo commit tiene un hash diferente al de &ldquo;Se agrega CONTRIBUTING.md&rdquo; de la rama `add-base-documents`.


<a id="org45b8fba"></a>

## Preguntas de discusi√≥n

1.  **¬øPor qu√© se considera que rebase es m√°s √∫til para mantener un historial de proyecto lineal en comparaci√≥n con merge?**
    
    Porque puedes ir desde el inicio del proyecto hasta el √∫ltimo commit de forma lineal tras realizar un `git rebase`. Con `git merge`, en cambio, las ramas se mantienen sin modificar e incluso se crea un commit adicional, lo cual puede resultar en un historial con varias bifurcaciones.
    
    Fuentes:
    
    -   [Merging vs. Rebasing | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
2.  **¬øQu√© problemas potenciales pueden surgir si haces rebase en una rama compartida con otros miembros del equipo?**
    
    `git rebase` reescribe la historia de una rama. No solo &ldquo;mueve&rdquo; los commits de una rama, sino que los reescribe con un hash diferente, por lo que son commits diferentes a los originales. En una rama p√∫blica en la que varios est√°n colaborando, esto resulta en problemas de coordinaci√≥n ya que gran parte de tu historia diferir√° del repositorio p√∫blico. Esto se har√≠a incluso peor si es que empujas esta nueva historia, ya que el progreso de los dem√°s desarrolladores podr√≠an depender de commits que t√©cnicamente ya no existen.
    
    Fuentes:
    
    -   [git rebase | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase)
3.  **¬øEn qu√© se diferencia cherry-pick de merge, y en qu√© situaciones preferir√≠as uno sobre el otro?**
    
    `cherry-pick` solo aplica un commit espec√≠fico de la historia de una rama como √∫ltimo commit de otra. No modifica la historia de ninguna de las ramas y se genera un nuevo commit. `git rebase`, en cambio, reescribe varios commits sobre otra rama, modificando la historia de estos en el proceso.
    
    Fuentes:
    
    -   [Merging vs. Rebasing | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
    -   [Git Cherry Pick | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/cherry-pick)


<a id="orga208616"></a>

# Ejercicios Te√≥ricos

1.  **¬øC√≥mo crees que el uso de git rebase ayuda a mejorar las pr√°cticas de DevOps, especialmente en la implementaci√≥n continua (CI/CD)? Discute los beneficios de mantener un historial lineal en el contexto de una entrega continua de c√≥digo y la automatizaci√≥n de pipelines.**
    
    Un historial lineal permite una f√°cil recorrido de tu lista de commits en el contexto de colaboraci√≥n continua. Cuando se realizan PRs en un repositorio, todos necesitan ver los commits que realizaste y un historial lineal ser√° m√°s f√°cil que un historial entre ramas. Adem√°s, si trabajas colaborativamente con otro desarrollador en la misma rama, el trabajo de este puede diferir del tuyo. Para solucionar esto, puedes hacer una fusi√≥n entre tu rama local y la del desarrollador o simplemente aplicar los cambios que realizaste sobre los del otro desarrollador con `git rebase`, lo cual resulta m√°s intuitivo.
    
    Para la automatizaci√≥n de pipelines, usar `git rebase` antes de un merge a main asegura que tus cambios pueden ser aplicados sin problemas y reduce conflictos de merging en el futuro al tener tu rama actualizada con la principal.
    
    Fuentes:
    
    -   [Merging vs. Rebasing | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/merging-vs-rebasing)
    -   [Squash, Rebase, Merge: Keeping Your CI/CD Pipelines Clean and Efficient üöÄ - D&#x2026;](https://dev.to/favxlaw/squash-rebase-merge-keeping-your-cicd-pipelines-clean-and-efficient-8cc)
2.  **Un equipo Scrum ha finalizado un sprint, pero durante la integraci√≥n final a la rama principal (main) descubren que solo algunos commits espec√≠ficos de la rama de una funcionalidad deben aplicarse a producci√≥n. ¬øC√≥mo podr√≠a ayudar git cherry-pick en este caso? Explica los beneficios y posibles complicaciones.**
    
    `git cherry-pick` ayuda precisamente en los escenarios en los que solo se requieren algunos commits de otra rama. En lugar de tener que realizar un merge o rebase, solo pueden elegir las funcionalidades que necesitan. De igual modo, esto puede permitir pruebas aisladas en donde solo se testean commits espec√≠ficos o por error se puede hacer un commit en una rama equivocada, por lo que solo se necesita hacer `git cherry pick` en la rama correcta. Sin embargo, tambi√©n puede producir escenarios en donde se duplican commits, como por ejemplo tratar de hacer `git cherry pick` despu√©s de un merge. Por lo tanto, se debe tener bastante cuidado al usar esta herramienta en bases de c√≥digo grandes.
    
    Fuentes:
    
    -   [Git Cherry-Pick: How to Select and Apply Specific Commits | DataCamp](https://www.datacamp.com/tutorial/git-cherry-pick)
    -   [Git Cherry Pick | Atlassian Git Tutorial](https://www.atlassian.com/git/tutorials/cherry-pick)


<a id="org36c957d"></a>

# Ejercicios pr√°cticos

1.  **Simulaci√≥n de un flujo de trabajo Scrum con git rebase y git merge**
    
    Despu√©s de crear el repositorio y los commits iniciales, el gr√°fico de commits se ve as√≠:
    
    ![Grafo de EP1 antes de rebase](../resources/img/A6_EP_1_1.jpg)
    
    -   **¬øQu√© sucede con el historial de commits despu√©s del rebase?**
        
        El historial se vuelve lineal.
        
        ![Grafo despu√©s de rebase](../resources/img/A6_EP_1_2.jpg)
        
        Despu√©s de `git-merge --ff-only`, se tiene el siguiente grafo:
        
        ![title](../resources/img/A6_EP_1_3.jpg)
    
    -   **¬øEn qu√© situaci√≥n aplicar√≠as una fusi√≥n fast-forward en un proyecto √°gil?**
        
        Cuando se requiran de cambios peque√±os, como *hotfixes*, se pueden usar fusiones fast-forward para tener un historial de commits lineal r√°pidamente. Fusiones no-fast-forward son m√°s √∫tiles cuando se tienen demasiados cambios y se requiera una visi√≥n clara entre dos ramas distintas.

2.  **Cherry-pick para integraci√≥n selectiva en un pipeline CI/CD**
    
    Desp√∫es de la creaci√≥n del repositorio, los commits y los cherry-picking, se tiene el siguiente gr√°fico en los que seralizaron dos cherry-pick.
    
    ![title](../resources/img/A6_EP_2_1.jpg)
    
    -   **¬øC√≥mo utilizar√≠as cherry-pick en un pipeline de CI/CD para mover solo ciertos cambios listos a producci√≥n?**
        
        Cherry-picking servir√≠a en estos casos para pasar a testeo solo algunos commits, como los que implementen funciones importantes, y aislar qu√© commits podr√≠an introducir errores. Esto ser√≠a m√°s dif√≠cil con un merge o rebase completo en donde todos los commits ser√≠an parte del pipeline desde un inicio.
    
    -   **¬øQu√© ventajas ofrece cherry-pick en un flujo de trabajo de DevOps?**
        
        Al igual que en la pregunta anterior, cherry-picking permite el desarrollo y despliege continuo al realizar cambios peque√±os y estables que permiten testear cambios m√≠nimos pero acumulables. Esto mantiene el ciclo de DevOps por permitir tener una base de c√≥digo estable y testeada de manera r√°pida.


<a id="org5710cd9"></a>

# Git, Scrum y Sprints


<a id="orgd6f8434"></a>

## Fase 1: Planificaci√≥n del sprint (sprint planning)


<a id="org117e6a9"></a>

### Ejercicio 1: Crear ramas de funcionalidades (feature branches)

![title](../resources/img/A6_scrum_1_1.jpg)

-   **¬øPor qu√© es importante trabajar en ramas de funcionalidades separadas durante un sprint?**
    
    Permite aislar el c√≥digo de las funcionalidades. Esto elimina el riesgo de conflictos al trabajar colaborativamente y realizar pruebas aisladas por funcionalidad en lugar de varias a la vez.


<a id="org9b00752"></a>

## Fase 2: Desarrollo del sprint (sprint execution)


<a id="org0f307e4"></a>

### Ejercicio 2: Integraci√≥n continua con git rebase

[title](../resources/img/A6_scrum_2_1.jpg)

-   **¬øQu√© ventajas proporciona el rebase durante el desarrollo de un sprint en t√©rminos de integraci√≥n continua?**
    
    Con `git-rebase` te aseguras de que la rama en la que est√©s trabajando se mantenga al d√≠a con los √∫ltimos cambios de la rama base, por lo que, adem√°s de asegurar que tu rama no est√© desactualizada, cuando se realice una fusi√≥n a esta √∫ltima se reducir√°n los conflictos de fusi√≥n.


<a id="org9b63802"></a>

## Fase 3: Revisi√≥n del sprint (sprint review)


<a id="org99acda5"></a>

### Ejercicio 3: Integraci√≥n selectiva con git cherry-pick

![title](../resources/img/A6_scrum_3_1.jpg)

-   **¬øC√≥mo ayuda \`git cherry-pick\` a mostrar avances de forma selectiva en un sprint review?**
    
    Con `git cherry-pick` puedes elegir solo los avances m√°s importantes en la rama principal cuando la rama de desarrollo es demasiado larga y tiene commits que no son relevantes para revisi√≥n.


<a id="org290fe7d"></a>

## Fase 4: Retrospectiva del sprint (sprint retrospective)


<a id="org345c435"></a>

### Ejercicio 4: Revisi√≥n de conflictos y resoluci√≥n

![title](../resources/img/A6_scrum_4_1.jpg)

-   **¬øC√≥mo manejas los conflictos de fusi√≥n al final de un sprint? ¬øC√≥mo puede el equipo mejorar la comunicaci√≥n para evitar conflictos grandes?**
    
    Los conflictos de fusi√≥n deben discutirse en grupo para hallar una soluci√≥n que mantenga las funcionalidades necesarias y que cumpla con est√°ndares establecidos seg√∫n los pipelines de pruebas. Para evitar estos problemas, es importante que los miembros comuniquen entre si los cambios importantes que van a realizar a los archivos del repositorio compartido. De igual modo, PRs peque√±os ayudan a evitar conflictos grandes en varios archivos y entre m√∫ltiples desarrolladores.


<a id="orgdca9680"></a>

## Fase 5: Fase de desarrollo, automatizaci√≥n de integraci√≥n continua (CI) con git rebase


<a id="orgbab3088"></a>

### Ejercicio 5: Automatizaci√≥n de rebase con hooks de Git

![title](../resources/img/A6_scrum_5_1.jpg)

-   **¬øQu√© ventajas y desventajas observas al automatizar el rebase en un entorno de CI/CD?**
    
    Automatizar el rebase permite el manejo constante de conflictos constantes con la rama principal. Esto reduce los riesgos futuros al realizar fusiones. Sin embargo, esto mueve la responsabilidad de resolver conflictos en un desarrollador en lugar de que sea un trabajo colaborativo.


<a id="orgd8eb8ed"></a>

## Navegando conflictos y versionado en un entorno DevOps

1.  **Inicializaci√≥n del proyecto y creaci√≥n de ramas**
    
    Despu√©s de inicalizar el proyecto y realizar unos commits iniciales, se tiene el siguiente gr√°fico
    
    ![title](../resources/img/A6_merge_1_1.jpg)

2.  **Fusi√≥n y recolecci√≥n de conflictos**
    
    Al realizar `git-merge` y luego `git checkout --ours` en `archivo_colaborativo.txt`, como en la siguiente imagen, se tiene el grafo que sigue.
    
    ![title](../resources/img/A6_merge_2_1.jpg)
    
    ![title](../resources/img/A6_merge_2_2.jpg)

3.  **Simulaci√≥n de fusiones y uso de git diff**
    
    Despu√©s de agregar cambios para simular, el grafo termina as√≠:
    
    ![title](../resources/img/A6_merge_3_1.jpg)
    
    Simulando una fusi√≥n y revisando los archivos en conflictos:
    
    ![title](../resources/img/A6_merge_3_2.jpg)
    
    ![title](../resources/img/A6_merge_3_3.jpg)

4.  **Uso de git mergetool**
    
    Utilizando vimdiff como herramienta para solucionar conflictos, se tiene el siguiente resultado:
    
    ![title](../resources/img/A6_merge_4_1.jpg)
    
    ![title](../resources/img/A6_merge_4_2.jpg)

5.  **Uso de git revert y git reset**
    
    Primero, creo un commit &ldquo;err√≥neo&rdquo;:
    
    ![title](../resources/img/A6_merge_5_1.jpg)
    
    -   Utilizando `git revert`
        
        ![title](../resources/img/A6_merge_5_2.jpg)
    
    -   Utilizando `git reset --mixed`, primero necesito cambios en staging pero sin cometer. Despu√©s del reset, estos cambios se quitan del √°rea de staging y el √≠ndice apunta al commit al que se hace reset.
        
        ![title](../resources/img/A6_merge_5_3.jpg)

6.  **Versionado sem√°ntico y etiquetado**
    
    Despu√©s de etiquetar el √∫ltimo commit, se tiene el siguiente grafo:
    
    ![title](../resources/img/A6_merge_6_1.jpg)

7.  **Aplicaci√≥n de git bisect para depuraci√≥n**
    
    Se usa de forma b√°sica `git bisect` para aislar el commit &ldquo;err√≥neo&rdquo;.
    
    ![title](../resources/img/A6_merge_7_1.jpg)

8.  **Documentaci√≥n y reflexi√≥n**
    -   Se document√≥ todos los comandos utilizados.
    
    -   **Documentaci√≥n**
        1.  La resoluci√≥n de conflictos con la fusi√≥n, ya sea de forma manual o con alguna mergetool, fomenta la colaboraci√≥n entre diversos miembros entre equipos, ya que algunos cambios podr√≠an irrumpir con cambios introducidos por otros. De igual modo, esto promueve la fusi√≥n constante para reducir el riesgo de conflictos grandes. Las mergetools en este contexto son importantes para facilitar el trabajo de resoluci√≥n de conflictos, el cual puede extenderse entre varios archivos. Finalmente, la fusi√≥n simulada tambi√©n ayuda a detectar conflictos mucho antes de que interfieran con la rama principal.
        
        2.  `revert` es especialmente √∫til para no modificar el historial de commits. En un contexto de alta colaboraci√≥n y comunicaci√≥n, borrar commits puede resultar en ramas no sincronizadas entre varios miembros y equipos, por lo que realizar commits expl√≠citos de correcci√≥n permite una mayor transparencia entre colaboradores. Aunque `reset` no sea recomendado, puede ser √∫til en ramas locales.
        
        3.  `bisect` agiliza la identificaci√≥n de errores introducidos por commits. En el contexto de DevOps, esto facilita el despliegue continuo al aislar errores, corregirlos y regresar a un c√≥digo funcional que pase por las pruebas necesarias.
        
        4.  Finalmente, el tagging permite hacer p√∫blicos los hitos m√°s importantes en el c√≥digo. Para el desarrollo e integraci√≥n continuos, marcar claramente el desarrollo en los commits permite evaluar el progreso del grupo e identificar las caracter√≠sticas a√±adidas en cada momento. Cuando se tiene un buen sistema de versionado, los grupos pueden revisar su progreso y asegurarse de estar al d√≠a con la √∫ltima version del c√≥digo.


<a id="orge2e932d"></a>

# Preguntas

1.  **Ejercicio para git checkout &#x2013;ours y git checkout &#x2013;theirs**
    -   Si el equipo A quiere conservar sus cambios, simplemente usar√≠a `git checkout --theirs` cuando cambie a la rama principal y fusione. Si el equipo B prefiere los cambios de A y fusionarlos a su rama, usar√≠a `git checkout --theirs` en su propia rama. Como ambos quieren mantener sus propios cambios, se espera que alguno fusione con `git checkout --theris` sobre la rama principal.
    -   Dependiendo de los cambios y conflictos introducidos, ambos comandos pueden ser √∫tiles. `--ours` permite mantener el c√≥digo de la rama principal, por lo que reducir√≠a posibles conflictos con otros miembros que trabajen sobre esta rama como referencia. Igualmente, al usar c√≥digo que ya pas√≥ por pruebas, se supera el pipeline CI/CD m√°s f√°cilmente. Una vez superado el conflicto, el pipeline se reanuda y se ejecutan las pruebas necesarias. `--theirs` tiene el uso opuesto y puede servir para corregir c√≥digo en la rama principal con el c√≥digo escrito en la rama desarrollada.
    -   La calidad se asegura con las pruebas implementadas en el pipeline CI/CD y con la revisi√≥n manual del c√≥digo. Si alguna versi√≥n claramente realiza cambios destructivos en el c√≥digo base, la elecci√≥n ser√° obvia, pero depender√° de las pruebas asegurar que alg√∫n c√≥digo sea el adecuado.

2.  **Ejercicio para git diff**
    -   `git diff` permite identificar cambios en archivos modificados. `git diff feature-branch..main`, en particular, compara los cambios introducidos por la rama feature-branch sobre main.
    
    -   Se pueden se√±alar qu√© archivos comparar entre ramas con argumentos adicionales en `git diff`, como por ejemplo `git diff feature-branch..main configuracion.yml`.
    
    -   Comparar cambios entre ramas es esencial, ya que esto permite decidir qu√© cambios introducir o no sobre una rama importante o compartida. Si es que algunos cambios introducen errores o modifican configuraciones importantes, es importante identificar estos cambios antes de que sean introducidos. Con esto, se mantiene la estabilidad del pipeline y de las ramas compartidas.

3.  **Ejercicio para git merge &#x2013;no-commit &#x2013;no-ff**
    -   Usar `git merge --no-commit --no-ff` implica actualizar mi rama local con la remota y luego utilizar este comando para simular una fusi√≥n en mi entorno local.
    
    -   En un flujo de trabajo √°gil, esta pr√°ctica evita errores antes de que sean introducidos por una fusi√≥n. Adem√°s, permite probar el c√≥digo localmente sin que se fusione a la rama remota, lo cual reduce conflictos futuros y problemas en el c√≥digo.
    
    -   En una pipeline, usar√≠a un archivo de configuraci√≥n, por ejemplo uno para GitHub Actions, el cual realice fusiones simuladas autom√°ticamente y ejecute pruebas automatizadas. En caso de error, el pipeline se detendr√≠a y reportar√≠a sus resultados, lo cual ahorra tiempo de ejecuci√≥n de la fusi√≥n simulada.

4.  **Ejercicio para git mergetool**
    -   Usar√≠a `git config --global merge.tool vimdiff`. En mi caso, estoy c√≥modo usando Vim, por lo que prefiero usar esta herramienta en particular. Al hacer un `merge` con conflictos, puedo llamar a `git mergetool` para utilizar vimdiff y solucionar los conflcitos de forma visual.
    
    -   Las herramientas visuales aceleran el proceso de reconocer diferencias entre archivos, adem√°s de reducir errores humanos. Sin embargo, cada miembro debe saber manejar estar herramientas y a veces podr√≠an no estar disponibles las herramientas preferidas de cada miembro.
    
    -   Para que los miembros tengan consistencia, todos tendr√≠an que usar las mismas herramientas con las mismas configuraciones. Esto puede ser f√°cil para herramientas b√°sicas, pero en el caso de herramientas m√°s especializadas, cada uno puede tener preferencias de configuraciones espec√≠ficas. En su defecto, usar VSCode ser√≠a ideal, ya que cada uno podr√≠a tener sus propias extensiones o configuraciones personales sin afectar est√°ndares grupales. Adem√°s, el flujo CI/CD podr√≠a verificar que la resoluci√≥n de conflictos sea v√°lida y estandarizada entre miembros y equipos.

5.  **Ejercicio para git reset**
    -   `git reset --soft`: Mueve el HEAD al commit especificado pero mantiene cualquier cambio en el √°rea de staging
    
    -   `git reset --mixed`: Mueve el HEAD al commit especificado y quita los cambios hechos del √°rea de staging.
    
    -   `git reset --hard`: Mueve el head al commit especificado y reinicia completamente el estado del directorio de trabajo al de este

6.  **Ejercicio para git revert**
    -   `git revert` permite rehacer un commit con otro que revierta los cambios introducidos por este. Esto es m√°s seguro para el pipeline, ya que no reescribe el historial de commits ni forzar empujes.
    
    -   Para asegurar que esta acci√≥n no afecte el pipeline se deben revertir commits que introduzcan errores, los cuales pueden identificarse con `git bisect`, y constantemente comparar con `git diff` los cambios introducidos para asegurarte de no romper la base de c√≥digo.
    
    -   `git revert` permite revertir un rango de commits haciendo `git revert <commit inicial>..<commit final>`. Para verificar introducir cambios desastrozos, se pasa la bandera `--no-commit` para verificar todos los cambios hechos con el nuevo commit de reversi√≥n.

7.  **Ejercicio para git stash**
    -   Primero, llamar√≠a a `git stash push` para guardar mis cambios sin commitear, cambiar√≠a a la rama que requiere de trabajo inmediatamente y, cuando termine, regresar√≠a a mi rama de trabajo y aplicar√≠a mis cambios nuevamente con `git stash pop`.
    
    -   `git stash` evita aplicar commits con cambios en progreso o incompletos, los cuales podr√≠an romper con el flujo del pipeline. Adem√°s, como en el caso anterior, este permite trabajar en ramas que requieren de atenci√≥n inmediata sin descartar cambios en los que se est√© trabajando.

8.  **Ejercicio para .gitignore**
    -   El `.gitignore` necesita abarcar todas las extensiones de configuraciones personales y logs en los repositorios locales de todos los desarrolladores y todos los equipos. Un ejemplo podr√≠a ser:
        
            *.git
            *.yml
            *.env
    
    -   El archivo `.gitignore` debe ser compartido por todos los desarrolladores para evitar que alg√∫n archivo secreto, de configuraci√≥n personal, o en general cualquiera que no deber√≠a ser p√∫blico sea empujado a la rama compartida. Caso contrario, este podr√≠a pasar desapercibido a lo largo de varios commits y contaminar una rama a trav√©s de su historia. En el peor caso, cuando un archivo con secretos es empujado, este es un riesgo de seguridad grave.

